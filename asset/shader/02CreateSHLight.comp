#version 430 core


layout (local_size_x=8, local_size_y=4, local_size_z=1) in;

uniform samplerCube cubeMap;

layout (std430, binding = 0) buffer SHLight {
    uvec4 sh[16];
};

const float pi = 3.1415926;

void atomicIntegral(int i, vec3 val)
{
    uint temp;
    float old;
    uint new;
    for (int c = 0; c < 3; ++c)
    {
        do
        {
            temp = sh[i][c];
            old = uintBitsToFloat(temp);
            new = floatBitsToUint(old + val[c]);
        } while(temp != atomicCompSwap(sh[i][c], temp,  new));
    }
}

void main()
{
    uvec3 globalSize = gl_NumWorkGroups * gl_WorkGroupSize;

    float deltaPhi = 2.0 * pi / float(globalSize.x);
    float delatTheta = pi / float(globalSize.y);
    float phi = float(gl_GlobalInvocationID.x) * deltaPhi;
    float theta = float(gl_GlobalInvocationID.y) * delatTheta;

    float cosTheta = cos(theta);
    float sinTheta = sin(theta);
    float cosPhi = cos(phi);
    float sinPhi = sin(phi);

    vec3 sampleVec = vec3(sinTheta * cosPhi,  sinTheta * sinPhi, cosTheta);
    vec3 color = textureLod(cubeMap, sampleVec, 0).rgb;
    float sr = delatTheta * deltaPhi * sinTheta;

    int index = 0;

    vec3 sh0 = 1 /2.0 * sqrt(1.0 / pi) * sr * color;
    atomicIntegral(index++, sh0);

    vec3 sh10 = 1/2.0 * sqrt(3.0 / pi) * cosTheta * sr * color;
    atomicIntegral(index++, sh10);
    vec3 sh11 = 1/2.0 * sqrt(3.0 / pi) * sinTheta * cosPhi * sr * color;
    atomicIntegral(index++, sh11);
    vec3 sh1_1 = 1/2.0 * sqrt(3.0 / pi) * sinTheta * sinPhi * sr * color;
    atomicIntegral(index++, sh1_1);

    vec3 sh20 = 1/4.0 * sqrt(5.0 / pi) * (3 * cosTheta * cosTheta - 1)  * sr * color;
    atomicIntegral(index++, sh20);
    vec3 sh21 = 1/2.0 * sqrt(15.0 / pi) * sinTheta * cosTheta * cosPhi * sr * color;
    atomicIntegral(index++, sh21);
    vec3 sh2_1 = 1/2.0 * sqrt(15.0 / pi) * sinTheta * cosTheta * sinPhi * sr * color;
    atomicIntegral(index++, sh2_1);
    vec3 sh22 = 1/4.0 * sqrt(15.0 / pi) * sinTheta * sinTheta * cos(2*phi) * sr * color;
    atomicIntegral(index++, sh22);
    vec3 sh2_2 = 1/4.0 * sqrt(15.0 / pi) * sinTheta * sinTheta * sin(2*phi) * sr * color;
    atomicIntegral(index++, sh2_2);

    vec3 sh30 = 1/4.0 * sqrt(7.0 / pi) * (5 * cosTheta * cosTheta * cosTheta - 3 * cosTheta) * sr * color;
    atomicIntegral(index++, sh30);
    vec3 sh31 = 1/4.0 * sqrt(10.5 / pi) * (5 * cosTheta * cosTheta - 1) * sinTheta * cosPhi * sr * color;
    atomicIntegral(index++, sh31);
    vec3 sh3_1 = 1/4.0 * sqrt(10.5 / pi) * (5 * cosTheta * cosTheta - 1) * sinTheta * sinPhi * sr * color;
    atomicIntegral(index++, sh3_1);
    vec3 sh32 = 1/4.0 * sqrt(105 / pi) * cosTheta * sinTheta * sinTheta * cos(2*phi) * sr * color;
    atomicIntegral(index++, sh32);
    vec3 sh3_2 = 1/4.0 * sqrt(105 / pi) * cosTheta * sinTheta * sinTheta * sin(2*phi) * sr * color;
    atomicIntegral(index++, sh3_2);
    vec3 sh33 = 1/4.0 * sqrt(17.5 / pi) * sinTheta * sinTheta * sinTheta * cos(3*phi) * sr * color;
    atomicIntegral(index++, sh33);
    vec3 sh3_3 = 1/4.0 * sqrt(17.5 / pi) * sinTheta * sinTheta * sinTheta * sin(3*phi) * sr * color;
    atomicIntegral(index++, sh3_3);

//    if (gl_GlobalInvocationID.x == 0 && gl_GlobalInvocationID.y == 0 && gl_GlobalInvocationID.z == 0)
//    {
//        sh[14].x = floatBitsToInt(float(globalSize.x));
//        sh[14].y = floatBitsToInt(float(globalSize.y));
//        sh[14].z = floatBitsToInt(float(globalSize.z));
//    }
//    atomicIntegral(15, vec3(sr));
}